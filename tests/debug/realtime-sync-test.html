<!DOCTYPE html>
<html>
<head>
    <title>Real-time Sync Test</title>
    <style>
        body { font-family: monospace; padding: 20px; }
        .window { border: 2px solid #333; padding: 10px; margin: 10px; }
        .connected { border-color: green; }
        .error { color: red; }
        .success { color: green; }
        pre { background: #f0f0f0; padding: 10px; }
    </style>
</head>
<body>
    <h1>Real-time Sync Test</h1>
    <p>This test verifies that operations sync between tabs in real-time.</p>
    
    <button onclick="openTestWindows()">Open Test Windows</button>
    <button onclick="testNodeCreate()">Test Create Node</button>
    <button onclick="testNodeMove()">Test Move Node</button>
    <button onclick="checkSync()">Check Sync Status</button>
    
    <div id="status"></div>
    <pre id="log"></pre>
    
    <script>
        let window1 = null;
        let window2 = null;
        
        const log = (msg, type = 'info') => {
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : '';
            document.getElementById('log').innerHTML += `[${timestamp}] <span class="${className}">${msg}</span>\n`;
            console.log(msg);
        };
        
        function openTestWindows() {
            // Open two windows side by side
            const width = window.screen.width / 2 - 50;
            const height = window.screen.height - 200;
            
            window1 = window.open('/', 'test1', `width=${width},height=${height},left=0,top=50`);
            window2 = window.open('/', 'test2', `width=${width},height=${height},left=${width + 50},top=50`);
            
            log('Opened two test windows');
            
            // Wait for them to load
            setTimeout(() => {
                checkBothWindows();
            }, 3000);
        }
        
        function checkBothWindows() {
            if (!window1 || !window2) {
                log('Windows not open', 'error');
                return false;
            }
            
            const app1 = window1.app;
            const app2 = window2.app;
            
            if (!app1 || !app2) {
                log('Apps not loaded', 'error');
                return false;
            }
            
            // Check network status
            const net1 = app1.networkLayer?.getStatus();
            const net2 = app2.networkLayer?.getStatus();
            
            log('Window 1 Network: ' + JSON.stringify(net1));
            log('Window 2 Network: ' + JSON.stringify(net2));
            
            // Check if both are in same project
            if (net1?.project?.id === net2?.project?.id) {
                log(`Both windows in project ${net1.project.id}`, 'success');
                return true;
            } else {
                log('Windows not in same project!', 'error');
                return false;
            }
        }
        
        async function testNodeCreate() {
            if (!checkBothWindows()) return;
            
            const app1 = window1.app;
            const app2 = window2.app;
            
            // Count nodes before
            const nodesBefore1 = app1.graph.nodes.length;
            const nodesBefore2 = app2.graph.nodes.length;
            
            log(`Nodes before - Window1: ${nodesBefore1}, Window2: ${nodesBefore2}`);
            
            // Create node in window 1
            log('Creating node in Window 1...');
            
            // Hook into window2's pipeline to detect incoming operations
            let receivedOperation = false;
            const originalExecute = app2.operationPipeline.execute.bind(app2.operationPipeline);
            app2.operationPipeline.execute = async (...args) => {
                const command = args[0];
                if (command && command.origin === 'remote' && command.type === 'node_create') {
                    log('Window 2 received node_create operation!', 'success');
                    receivedOperation = true;
                }
                return originalExecute(...args);
            };
            
            // Create node
            await app1.operationPipeline.execute('node_create', {
                type: 'media/image',
                position: [100, 100],
                properties: { src: 'test.jpg' }
            });
            
            // Wait for sync
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Check nodes after
            const nodesAfter1 = app1.graph.nodes.length;
            const nodesAfter2 = app2.graph.nodes.length;
            
            log(`Nodes after - Window1: ${nodesAfter1}, Window2: ${nodesAfter2}`);
            
            if (nodesAfter1 === nodesBefore1 + 1 && nodesAfter2 === nodesBefore2 + 1) {
                log('✅ Node creation synced successfully!', 'success');
            } else {
                log('❌ Node creation did not sync', 'error');
            }
            
            if (!receivedOperation) {
                log('⚠️ Window 2 did not receive the operation via WebSocket', 'error');
            }
            
            // Restore original execute
            app2.operationPipeline.execute = originalExecute;
        }
        
        async function testNodeMove() {
            if (!checkBothWindows()) return;
            
            const app1 = window1.app;
            const app2 = window2.app;
            
            if (app1.graph.nodes.length === 0) {
                log('No nodes to move', 'error');
                return;
            }
            
            const node1 = app1.graph.nodes[0];
            const node2 = app2.graph.nodes[0];
            
            if (!node1 || !node2) {
                log('Could not find nodes in both windows', 'error');
                return;
            }
            
            const posBefore = [...node1.pos];
            log(`Node position before: [${posBefore}]`);
            
            // Move node in window 1
            log('Moving node in Window 1...');
            await app1.operationPipeline.execute('node_move', {
                nodeId: node1.id,
                position: [200, 200]
            });
            
            // Wait for sync
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Check positions
            const pos1 = app1.graph.nodes[0].pos;
            const pos2 = app2.graph.nodes[0].pos;
            
            log(`Window 1 position: [${pos1}]`);
            log(`Window 2 position: [${pos2}]`);
            
            if (pos1[0] === 200 && pos1[1] === 200 && pos2[0] === 200 && pos2[1] === 200) {
                log('✅ Node move synced successfully!', 'success');
            } else {
                log('❌ Node move did not sync', 'error');
            }
        }
        
        function checkSync() {
            if (!checkBothWindows()) return;
            
            const app1 = window1.app;
            const app2 = window2.app;
            
            // Check socket listeners
            if (app1.networkLayer?.socket) {
                const events = app1.networkLayer.socket._callbacks || {};
                log('Window 1 socket events: ' + Object.keys(events).join(', '));
            }
            
            if (app2.networkLayer?.socket) {
                const events = app2.networkLayer.socket._callbacks || {};
                log('Window 2 socket events: ' + Object.keys(events).join(', '));
            }
            
            // Check if canvas_operation listener exists
            const hasListener1 = app1.networkLayer?.socket?._callbacks?.canvas_operation;
            const hasListener2 = app2.networkLayer?.socket?._callbacks?.canvas_operation;
            
            log(`Window 1 has canvas_operation listener: ${!!hasListener1}`);
            log(`Window 2 has canvas_operation listener: ${!!hasListener2}`);
        }
    </script>
</body>
</html>