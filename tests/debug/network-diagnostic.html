<!DOCTYPE html>
<html>
<head>
    <title>Network Layer Diagnostic</title>
    <style>
        body { font-family: monospace; padding: 20px; }
        .section { margin: 20px 0; padding: 10px; border: 1px solid #ccc; }
        .success { color: green; }
        .error { color: red; }
        .warning { color: orange; }
        button { margin: 5px; padding: 10px; }
        #log { background: #f0f0f0; padding: 10px; white-space: pre-wrap; }
    </style>
</head>
<body>
    <h1>Network Layer Diagnostic</h1>
    
    <div class="section">
        <h2>1. Check Dependencies</h2>
        <div id="deps"></div>
    </div>
    
    <div class="section">
        <h2>2. Load Order</h2>
        <div id="loadOrder"></div>
    </div>
    
    <div class="section">
        <h2>3. Manual Test</h2>
        <button onclick="loadNetworkLayer()">Load NetworkLayer</button>
        <button onclick="createInstance()">Create Instance</button>
        <button onclick="connect()">Connect</button>
        <button onclick="joinProject1()">Join Project 1</button>
        <button onclick="testBroadcast()">Test Broadcast</button>
    </div>
    
    <div class="section">
        <h2>4. Log</h2>
        <pre id="log"></pre>
    </div>
    
    <script>
        let networkLayer = null;
        let loadedScripts = [];
        
        function log(msg, type = 'info') {
            const logEl = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const typeSymbol = type === 'error' ? '❌' : type === 'warning' ? '⚠️' : '✅';
            logEl.textContent += `[${timestamp}] ${typeSymbol} ${msg}\n`;
            console.log(msg);
        }
        
        // Check initial dependencies
        function checkDeps() {
            const deps = document.getElementById('deps');
            const checks = [
                { name: 'Socket.IO', check: () => typeof io !== 'undefined' },
                { name: 'CONFIG', check: () => typeof CONFIG !== 'undefined' },
                { name: 'NetworkLayer', check: () => typeof NetworkLayer !== 'undefined' },
                { name: 'window.app', check: () => typeof window.app !== 'undefined' }
            ];
            
            deps.innerHTML = checks.map(c => {
                const exists = c.check();
                return `<div class="${exists ? 'success' : 'error'}">${c.name}: ${exists ? '✅ Available' : '❌ Not Available'}</div>`;
            }).join('');
        }
        
        // Track script loading
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                mutation.addedNodes.forEach((node) => {
                    if (node.tagName === 'SCRIPT' && node.src) {
                        const scriptName = node.src.split('/').pop();
                        loadedScripts.push({
                            name: scriptName,
                            time: Date.now(),
                            loaded: false
                        });
                        
                        node.onload = () => {
                            const script = loadedScripts.find(s => s.name === scriptName);
                            if (script) script.loaded = true;
                            updateLoadOrder();
                        };
                    }
                });
            });
        });
        observer.observe(document.head, { childList: true });
        
        function updateLoadOrder() {
            const loadOrderEl = document.getElementById('loadOrder');
            loadOrderEl.innerHTML = loadedScripts.map(s => {
                return `<div class="${s.loaded ? 'success' : 'warning'}">${s.name}: ${s.loaded ? '✅ Loaded' : '⏳ Loading...'}</div>`;
            }).join('');
        }
        
        // Manual testing functions
        async function loadNetworkLayer() {
            log('Loading dependencies...');
            
            // Load CONFIG
            if (typeof CONFIG === 'undefined') {
                await loadScript('/js/utils/config.js');
                log('CONFIG loaded');
            }
            
            // Load Socket.IO
            if (typeof io === 'undefined') {
                try {
                    await loadScript('http://localhost:3000/socket.io/socket.io.js');
                    log('Socket.IO loaded');
                } catch (e) {
                    log('Failed to load Socket.IO: ' + e.message, 'error');
                    return;
                }
            }
            
            // Load NetworkLayer
            if (typeof NetworkLayer === 'undefined') {
                await loadScript('/js/core/NetworkLayer.js');
                log('NetworkLayer loaded');
            }
            
            checkDeps();
        }
        
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = () => reject(new Error('Failed to load: ' + src));
                document.head.appendChild(script);
            });
        }
        
        function createInstance() {
            if (typeof NetworkLayer === 'undefined') {
                log('NetworkLayer not loaded!', 'error');
                return;
            }
            
            // Create mock app
            const mockApp = {
                updateConnectionStatus: (status) => log(`Connection status: ${status}`),
                updateActiveUsers: (users) => log(`Active users: ${JSON.stringify(users)}`),
                showError: (msg) => log(`App error: ${msg}`, 'error'),
                handleStateSync: (state) => log(`State sync received`),
                operationPipeline: {
                    createCommand: (type, params) => ({ 
                        id: 'test-' + Date.now(), 
                        type, 
                        params,
                        timestamp: Date.now()
                    }),
                    execute: () => Promise.resolve()
                }
            };
            
            networkLayer = new NetworkLayer(mockApp);
            log('NetworkLayer instance created');
            log('Initial status: ' + JSON.stringify(networkLayer.getStatus()));
        }
        
        async function connect() {
            if (!networkLayer) {
                log('Create instance first!', 'error');
                return;
            }
            
            try {
                log('Connecting...');
                await networkLayer.connect();
                log('Connected successfully!');
                log('Status: ' + JSON.stringify(networkLayer.getStatus()));
            } catch (error) {
                log('Connection failed: ' + error.message, 'error');
            }
        }
        
        function joinProject1() {
            if (!networkLayer) {
                log('Create instance first!', 'error');
                return;
            }
            
            if (!networkLayer.isConnected) {
                log('Connect first!', 'error');
                return;
            }
            
            log('Joining project 1...');
            networkLayer.joinProject(1);
            
            // Check status after delay
            setTimeout(() => {
                const status = networkLayer.getStatus();
                log('Status after join: ' + JSON.stringify(status));
                if (status.project) {
                    log('Successfully joined project!', 'success');
                } else {
                    log('Failed to join project', 'error');
                }
            }, 1000);
        }
        
        function testBroadcast() {
            if (!networkLayer) {
                log('Create instance first!', 'error');
                return;
            }
            
            const command = {
                id: 'test-' + Date.now(),
                type: 'node_move',
                params: { nodeId: 1, x: 100, y: 100 },
                timestamp: Date.now()
            };
            
            log('Broadcasting test command...');
            networkLayer.broadcast(command);
            log('Check console for broadcast result');
        }
        
        // Initial check
        checkDeps();
        updateLoadOrder();
        
        // Auto-refresh checks
        setInterval(() => {
            checkDeps();
        }, 1000);
    </script>
</body>
</html>